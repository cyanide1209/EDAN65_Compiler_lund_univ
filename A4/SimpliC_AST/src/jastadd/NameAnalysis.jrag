import java.util.Set;
import java.util.HashSet;

aspect NameAnalysis {
	// ID_DECL
	inh IdDecl IdDecl.lookup(String name);
	syn boolean IdDecl.isMultiDeclared() = lookup(getID()) != this;

	//ID_USE
	syn IdDecl IdUse.decl() = lookup(getID());
	inh IdDecl IdUse.lookup(String name);

	//PROGRAM
	eq Program.getChild().lookup(String name) {
		for (Function f : getFunctions()) {
			IdDecl decl = f.getIdDecl();
			if(decl.getID.equals(name)){
				return decl;
			}
		}
		return unknownDecl;
	}

	//FUNCTION
	inh IdDecl Function.lookup(String name);

	syn IdDecl Function.localLookup(String name){
		for (int i = 0; i < getNumArguments(); i++) {
			if (getArgument(i).getID().equals(name)) {
				return getArgument(i);
			}
		}
		for (int i = 0; i < getNUmStatements(); i++) {
			IdDecl decl = s.localLookup(name);
			if (getStatement(i).getID().equals(name)) {
				return getStatement(i);
			}	
		}
		return unknownDecl;
	}

	eq Function.getStatement(int index).lookup(String name) {
		IdDecl decl = localLookup(name, index);
		return !decl.isUnknown() ? decl : lookup(name);
	}

	eq Function.getArgument(int index).lookup(String name) {
		IdDecl decl = localLookup(name, index);
		return !decl.isUnknown() ? decl : lookup(name);
	}

	//STATEMENT
	inh IdDecl Stmt.lookup(String name);
	syn IdDecl Stmt.localLookup(String name) = unknownDecl();

	syn IdDecl Declaration.localLookup(String name){
		return getIdDecl().getId().equals(name) ? getIdDecl() : unknownDecl();
	}
}
aspect CircularDefinitions {
	inh boolean IdUse.inExpression(IdDecl decl);
	syn boolean IdUse.isCircular() = inExpression(decl());

	inh boolean Statement.inExpression(IdDecl decl);
	eq Binding.getValue().inExpression(IdDecl decl) = getName() == decl || inExpression(decl);

	eq Program.getChild().inExpression(IdDecl decl) = false;
}



	// public class SymbolTable {
	// 	private static final SymbolTable BOTTOM = new SymbolTable() {
	// 		@Override
	// 		public boolean declare(String name) {
	// 			throw new UnsupportedOperationException(
	// 					"cannot add name to bottom of name stack");
	// 		}
	// 		@Override
	// 		public boolean lookup(String name) {
	// 			return false;
	// 		}
	// 	};

	// 	private final SymbolTable tail;
	// 	private final Set<String> names = new HashSet<String>();

	// 	public SymbolTable() {
	// 		tail = BOTTOM;
	// 	}

	// 	public SymbolTable(SymbolTable tail) {
	// 		this.tail = tail;
	// 	}

	// 	/**
	// 	 * Attempt to add a new name to the symbol table.
	// 	 * @return true if name was not already declared
	// 	 */
	// 	public boolean declare(String name) {
	// 		return names.add(name);
	// 	}

	// 	/**
	// 	 * @return true if name has been declared
	// 	 */
	// 	public boolean lookup(String name) {
	// 		return names.contains(name) || tail.lookup(name);
	// 	}

	// 	/**
	// 	 * Push a new table on the stack.
	// 	 * @return the new top of the stack
	// 	 */
	// 	public SymbolTable push() {
	// 		return new SymbolTable(this);
	// 	}
	// }

    // /**
	//  * @param err where to write error messages
	//  */
	// public void Program.checkNames(PrintStream err) {
	// 	SymbolTable symbols = new SymbolTable();
	// 	symbols.declare("print");
	// 	symbols.declare("read");
	// 	checkNames(err, symbols);
	// }

	// /**
	//  * @param err where to write error messages
	//  * @param symbols symbol table
	//  */
	// public void ASTNode.checkNames(PrintStream err, SymbolTable symbols) {
	// 	for (int i = 0; i < getNumChild(); ++i) {
	// 		getChild(i).checkNames(err, symbols);
	// 	}
	// }

	// public void IdDecl.checkNames(PrintStream err, SymbolTable symbols) {
	// 	if (!symbols.declare(getID())) {
	// 		err.format("Error at line %d: symbol \'%s\' is already declared!", getLine(), getID());
	// 		err.println();
	// 		System.exit(1);
	// 	}
	// }

    // public void Function.checkNames(PrintStream err, SymbolTable symbols) {
	// 	getIdDecl().checkNames(err, symbols);
	// 	SymbolTable functionsymbols = symbols.push();
	// 	for (Argument a : getArguments()) {
	// 		a.checkNames(err, functionsymbols);
	// 	}
	// 	symbols = symbols.push();
    //     for (Statement s : getStatements()) {
    //         s.checkNames(err, functionsymbols);
    //     }
	// }

    // public void If.checkNames(PrintStream err, SymbolTable symbols) {
	// 	getExpression().checkNames(err, symbols);
    //     SymbolTable ifsymbols = symbols.push();
    //     for (Statement s : getStatements()) {
    //         s.checkNames(err, ifsymbols);
    //     }
    //     if (hasElse()) {
	// 		getElse().checkNames(err, symbols.push());
	// 	}
	// }

    // public void Else.checkNames(PrintStream err, SymbolTable symbols) {
    //     SymbolTable elsesymbols = symbols.push();
    //     for (Statement s : getStatements()) {
    //         s.checkNames(err, elsesymbols);
    //     }
	// } 
    
    // public void While.checkNames(PrintStream err, SymbolTable symbols) {
	// 	getExpression().checkNames(err, symbols);
    //     SymbolTable whilesymbols = symbols.push();
    //     for (Statement s : getStatements()) {
    //         s.checkNames(err, whilesymbols);
    //     }
	// }  

	// public void IdUse.checkNames(PrintStream err, SymbolTable symbols) {
	// 	if (!symbols.lookup(getID())) {
	// 		err.format("Error at line %d: symbol \'%s\' has not been declared before this use!", getLine(), getID());
	// 		err.println();
	// 		System.exit(1);
	// 	}
	// }

	// /**
	//  * Helper method
	//  * @return line number of this token
	//  */
	// public int ASTNode.getLine() {
	// 	return getLine(getStart());
	// }